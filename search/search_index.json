{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"support/","text":"Something will be here in future","title":"Support"},{"location":"code/loaders/","text":"LoaderType Enum for the different loader types. Source code in pyi18n/loaders.py 6 7 8 9 10 class LoaderType : \"\"\" Enum for the different loader types. \"\"\" BASE : str = \"base\" YAML : str = \"yaml\" JSON : str = \"json\" PyI18nBaseLoader PyI18n Base Loader class, supports yaml and json Attributes: Name Type Description load_path str path to translations _type str loader type Methods load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path __load_file (str, str, object, str) -> dict: return file content Source code in pyi18n/loaders.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class PyI18nBaseLoader : \"\"\" PyI18n Base Loader class, supports yaml and json Attributes: load_path (str): path to translations _type (str): loader type Methods: load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path __load_file (str, str, object, str) -> dict: return file content \"\"\" _type : str = LoaderType . BASE def __init__ ( self , load_path : str = \"locales/\" ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations Returns: None \"\"\" self . load_path : str = load_path def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Returns: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Returns: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ] def type ( self ) -> str : \"\"\" Return loader type Returns: str: loader type \"\"\" return self . _type def get_path ( self ) -> str : \"\"\" Return loader path Returns: str: loader path \"\"\" return self . load_path __init__ ( load_path = 'locales/' ) Initialize loader class Parameters: Name Type Description Default load_path str path to translations 'locales/' Returns: Type Description None None Source code in pyi18n/loaders.py 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , load_path : str = \"locales/\" ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations Returns: None \"\"\" self . load_path : str = load_path __load_file ( file_path , ext , ser_mod , locale ) loads content, should not be called directly Returns: Name Type Description dict dict loaded content Source code in pyi18n/loaders.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Returns: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ] get_path () Return loader path Returns: Name Type Description str str loader path Source code in pyi18n/loaders.py 104 105 106 107 108 109 110 111 def get_path ( self ) -> str : \"\"\" Return loader path Returns: str: loader path \"\"\" return self . load_path load ( locales , ser_mod ) Load translations for given locales, should be overridden in child classes. Parameters: Name Type Description Default locales tuple locales to load required Returns: Name Type Description dict dict loaded translations Notes Custom load function should be implemented in child classes and return python dict Source code in pyi18n/loaders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Returns: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded type () Return loader type Returns: Name Type Description str str loader type Source code in pyi18n/loaders.py 95 96 97 98 99 100 101 102 def type ( self ) -> str : \"\"\" Return loader type Returns: str: loader type \"\"\" return self . _type PyI18nJsonLoader Bases: PyI18nBaseLoader PyI18n JSON Loader class Attributes: Name Type Description load_path str path to translations _type str loader type Methods load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path Source code in pyi18n/loaders.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class PyI18nJsonLoader ( PyI18nBaseLoader ): \"\"\" PyI18n JSON Loader class Attributes: load_path (str): path to translations _type (str): loader type Methods: load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path \"\"\" _type : str = LoaderType . JSON def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , json ) load ( locales ) Load translations for given locales using json Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Returns: Name Type Description dict dict loaded translations Source code in pyi18n/loaders.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , json ) PyI18nYamlLoader Bases: PyI18nBaseLoader PyI18n YAML Loader class Attributes: Name Type Description load_path str path to translations _type str loader type Methods load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path Source code in pyi18n/loaders.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class PyI18nYamlLoader ( PyI18nBaseLoader ): \"\"\" PyI18n YAML Loader class Attributes: load_path (str): path to translations _type (str): loader type Methods: load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path \"\"\" _type : str = LoaderType . YAML def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , yaml ) load ( locales ) Load translations for given locales using yaml Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Returns: Name Type Description dict dict loaded translations Source code in pyi18n/loaders.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , yaml )","title":"Loaders"},{"location":"code/loaders/#pyi18n.loaders.LoaderType","text":"Enum for the different loader types. Source code in pyi18n/loaders.py 6 7 8 9 10 class LoaderType : \"\"\" Enum for the different loader types. \"\"\" BASE : str = \"base\" YAML : str = \"yaml\" JSON : str = \"json\"","title":"LoaderType"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader","text":"PyI18n Base Loader class, supports yaml and json Attributes: Name Type Description load_path str path to translations _type str loader type Methods load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path __load_file (str, str, object, str) -> dict: return file content Source code in pyi18n/loaders.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class PyI18nBaseLoader : \"\"\" PyI18n Base Loader class, supports yaml and json Attributes: load_path (str): path to translations _type (str): loader type Methods: load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path __load_file (str, str, object, str) -> dict: return file content \"\"\" _type : str = LoaderType . BASE def __init__ ( self , load_path : str = \"locales/\" ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations Returns: None \"\"\" self . load_path : str = load_path def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Returns: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Returns: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ] def type ( self ) -> str : \"\"\" Return loader type Returns: str: loader type \"\"\" return self . _type def get_path ( self ) -> str : \"\"\" Return loader path Returns: str: loader path \"\"\" return self . load_path","title":"PyI18nBaseLoader"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.__init__","text":"Initialize loader class Parameters: Name Type Description Default load_path str path to translations 'locales/' Returns: Type Description None None Source code in pyi18n/loaders.py 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , load_path : str = \"locales/\" ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations Returns: None \"\"\" self . load_path : str = load_path","title":"__init__()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.__load_file","text":"loads content, should not be called directly Returns: Name Type Description dict dict loaded content Source code in pyi18n/loaders.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Returns: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ]","title":"__load_file()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.get_path","text":"Return loader path Returns: Name Type Description str str loader path Source code in pyi18n/loaders.py 104 105 106 107 108 109 110 111 def get_path ( self ) -> str : \"\"\" Return loader path Returns: str: loader path \"\"\" return self . load_path","title":"get_path()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.load","text":"Load translations for given locales, should be overridden in child classes. Parameters: Name Type Description Default locales tuple locales to load required Returns: Name Type Description dict dict loaded translations Notes Custom load function should be implemented in child classes and return python dict Source code in pyi18n/loaders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Returns: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded","title":"load()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.type","text":"Return loader type Returns: Name Type Description str str loader type Source code in pyi18n/loaders.py 95 96 97 98 99 100 101 102 def type ( self ) -> str : \"\"\" Return loader type Returns: str: loader type \"\"\" return self . _type","title":"type()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nJsonLoader","text":"Bases: PyI18nBaseLoader PyI18n JSON Loader class Attributes: Name Type Description load_path str path to translations _type str loader type Methods load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path Source code in pyi18n/loaders.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class PyI18nJsonLoader ( PyI18nBaseLoader ): \"\"\" PyI18n JSON Loader class Attributes: load_path (str): path to translations _type (str): loader type Methods: load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path \"\"\" _type : str = LoaderType . JSON def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , json )","title":"PyI18nJsonLoader"},{"location":"code/loaders/#pyi18n.loaders.PyI18nJsonLoader.load","text":"Load translations for given locales using json Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Returns: Name Type Description dict dict loaded translations Source code in pyi18n/loaders.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , json )","title":"load()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nYamlLoader","text":"Bases: PyI18nBaseLoader PyI18n YAML Loader class Attributes: Name Type Description load_path str path to translations _type str loader type Methods load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path Source code in pyi18n/loaders.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class PyI18nYamlLoader ( PyI18nBaseLoader ): \"\"\" PyI18n YAML Loader class Attributes: load_path (str): path to translations _type (str): loader type Methods: load (tuple, object) -> dict: load translations for given locales and returns as python dict type () -> str: return loader type get_path () -> str: return loader path \"\"\" _type : str = LoaderType . YAML def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , yaml )","title":"PyI18nYamlLoader"},{"location":"code/loaders/#pyi18n.loaders.PyI18nYamlLoader.load","text":"Load translations for given locales using yaml Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Returns: Name Type Description dict dict loaded translations Source code in pyi18n/loaders.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Returns: dict: loaded translations \"\"\" return super () . load ( locales , yaml )","title":"load()"},{"location":"code/pyi18n/","text":"Documentation for PyI18n class Main i18n localization class Attributes: Name Type Description available_locales tuple list of available locales load_path str path to locales directory _loaded_translations dict (class attribute) dictionary of loaded translations Methods gettext(locale, path, **kwargs) -> Union[dict, str] Private Methods __find (path, locale) -> Union[dict, str] __pyi18n_init () -> None Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n (( \"en\" , \"jp\" ), \"locales/\" ) >>> pyi18n . gettext ( \"en\" , \"hello.world\" ) 'Hello, world!' >>> pyi18n . gettext ( \"jp\" , \"hello.world\" ) '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' Source code in pyi18n/pyi18n.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class PyI18n : \"\"\" Main i18n localization class Attributes: available_locales (tuple): list of available locales load_path (str): path to locales directory _loaded_translations (dict): (class attribute) dictionary of loaded translations Methods: gettext(locale, path, **kwargs) -> Union[dict, str] Private Methods: __find (path, locale) -> Union[dict, str] __pyi18n_init () -> None Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n((\"en\", \"jp\"), \"locales/\") >>> pyi18n.gettext(\"en\", \"hello.world\") 'Hello, world!' >>> pyi18n.gettext(\"jp\", \"hello.world\") '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' \"\"\" _loaded_translations : dict = {} def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Returns: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init () def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales ) def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \" def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader __find ( path , locale ) Find translation for given path and locale Parameters: Name Type Description Default path str path to translation required locale str locale to get translation for required Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Source code in pyi18n/pyi18n.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \" __init__ ( available_locales , load_path = 'locales/' , loader = None ) Initialize i18n class Parameters: Name Type Description Default available_locales tuple list of available locales required load_path str path to locales directory 'locales/' Returns: Type Description None None Source code in pyi18n/pyi18n.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Returns: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init () __pyi18n_init () validator and loader for translations Raises: Type Description ValueError if locale is not available in self.available_locales FileNotFoundError if translation file is not found Source code in pyi18n/pyi18n.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales ) get_loader () Return loader class Returns: Name Type Description PyI18nBaseLoader PyI18nBaseLoader loader class Source code in pyi18n/pyi18n.py 135 136 137 138 139 140 141 142 def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader gettext ( locale , path , ** kwargs ) Get translation for given locale and path Parameters: Name Type Description Default locale str locale to get translation for required path str path to translation required **kwargs dict interpolation variables {} Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Raises: Type Description ValueError if locale is not in self.available_locales Source code in pyi18n/pyi18n.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded","title":"PyI18n class"},{"location":"code/pyi18n/#documentation-for-pyi18n-class","text":"Main i18n localization class Attributes: Name Type Description available_locales tuple list of available locales load_path str path to locales directory _loaded_translations dict (class attribute) dictionary of loaded translations Methods gettext(locale, path, **kwargs) -> Union[dict, str] Private Methods __find (path, locale) -> Union[dict, str] __pyi18n_init () -> None Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n (( \"en\" , \"jp\" ), \"locales/\" ) >>> pyi18n . gettext ( \"en\" , \"hello.world\" ) 'Hello, world!' >>> pyi18n . gettext ( \"jp\" , \"hello.world\" ) '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' Source code in pyi18n/pyi18n.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class PyI18n : \"\"\" Main i18n localization class Attributes: available_locales (tuple): list of available locales load_path (str): path to locales directory _loaded_translations (dict): (class attribute) dictionary of loaded translations Methods: gettext(locale, path, **kwargs) -> Union[dict, str] Private Methods: __find (path, locale) -> Union[dict, str] __pyi18n_init () -> None Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n((\"en\", \"jp\"), \"locales/\") >>> pyi18n.gettext(\"en\", \"hello.world\") 'Hello, world!' >>> pyi18n.gettext(\"jp\", \"hello.world\") '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' \"\"\" _loaded_translations : dict = {} def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Returns: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init () def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales ) def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \" def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader","title":"Documentation for PyI18n class"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.__find","text":"Find translation for given path and locale Parameters: Name Type Description Default path str path to translation required locale str locale to get translation for required Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Source code in pyi18n/pyi18n.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \"","title":"__find()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.__init__","text":"Initialize i18n class Parameters: Name Type Description Default available_locales tuple list of available locales required load_path str path to locales directory 'locales/' Returns: Type Description None None Source code in pyi18n/pyi18n.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Returns: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init ()","title":"__init__()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.__pyi18n_init","text":"validator and loader for translations Raises: Type Description ValueError if locale is not available in self.available_locales FileNotFoundError if translation file is not found Source code in pyi18n/pyi18n.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales )","title":"__pyi18n_init()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.get_loader","text":"Return loader class Returns: Name Type Description PyI18nBaseLoader PyI18nBaseLoader loader class Source code in pyi18n/pyi18n.py 135 136 137 138 139 140 141 142 def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader","title":"get_loader()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.gettext","text":"Get translation for given locale and path Parameters: Name Type Description Default locale str locale to get translation for required path str path to translation required **kwargs dict interpolation variables {} Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Raises: Type Description ValueError if locale is not in self.available_locales Source code in pyi18n/pyi18n.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded","title":"gettext()"},{"location":"code/tasks/","text":"Documentation for tasks module normalize.py __perform_normalize ( locales , locale_path ) private method to perform normalization, should not be called directly Source code in pyi18n/tasks/normalize.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __perform_normalize ( locales : set , locale_path : str ) -> None : \"\"\" private method to perform normalization, should not be called directly\"\"\" for subclass in loaders . PyI18nBaseLoader . __subclasses__ (): if subclass . __name__ == \"PyI18nXMLLoader\" \\ and environ [ \"PYI18N_TEST_ENV\" ]: continue loader : loaders . PyI18nBaseLoader = subclass ( locale_path ) content : dict = loader . load ( locales ) sorted_content : dict = __sort_nested ( content ) __save_normalized ( locales , loader , locale_path , sorted_content ) __save_normalized ( locales , loader , locale_path , sorted_content ) private function to save the normalized content, should not be called directly. Source code in pyi18n/tasks/normalize.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __save_normalized ( locales : set , loader : loaders . PyI18nBaseLoader , locale_path : str , sorted_content : dict ) -> None : \"\"\" private function to save the normalized content, should not be called directly.\"\"\" ext : str = loader . type () . replace ( 'yaml' , 'yml' ) dumper : str = { \"json\" : lambda x , y : json_dump ( x , y , indent = 4 , sort_keys = True ), \"yml\" : yaml_dump , \"xml\" : lambda x , _ : xml_dump ( x , pretty = True ) } for locale in locales : file_path : str = f \" { locale_path }{ locale } . { ext } \" with open ( file_path , \"w\" , encoding = \"utf-8\" ) as _f : dumper [ ext ]({ locale : sorted_content [ locale ]}, _f ) __sort_nested ( dictionary ) private function to sort nested dictionaries Source code in pyi18n/tasks/normalize.py 73 74 75 def __sort_nested ( dictionary : dict ) -> dict : \"\"\" private function to sort nested dictionaries \"\"\" return { k : dict ( sorted ( v . items ())) for k , v in dictionary . items ()} normalize_locales ( locale_path = 'locales/' ) Sorts the keys in alphabetically order, and overrides files Source code in pyi18n/tasks/normalize.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def normalize_locales ( locale_path : str = \"locales/\" ) -> dict : \"\"\" Sorts the keys in alphabetically order, and overrides files \"\"\" locale_path : str = f \" { getcwd () } / { locale_path } \" if not exists ( locale_path ): print ( f \"[ERROR] { locale_path } does not exist\" ) exit ( 1 ) locales : set = set ([ x . split ( '.' )[ 0 ] for x in listdir ( locale_path )]) if not locales : print ( f \"[ERROR] { locale_path } is empty\" ) exit ( 1 ) __perform_normalize ( locales , locale_path )","title":"Tasks"},{"location":"code/tasks/#documentation-for-tasks-module","text":"","title":"Documentation for tasks module"},{"location":"code/tasks/#normalizepy","text":"","title":"normalize.py"},{"location":"code/tasks/#pyi18n.tasks.normalize.__perform_normalize","text":"private method to perform normalization, should not be called directly Source code in pyi18n/tasks/normalize.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __perform_normalize ( locales : set , locale_path : str ) -> None : \"\"\" private method to perform normalization, should not be called directly\"\"\" for subclass in loaders . PyI18nBaseLoader . __subclasses__ (): if subclass . __name__ == \"PyI18nXMLLoader\" \\ and environ [ \"PYI18N_TEST_ENV\" ]: continue loader : loaders . PyI18nBaseLoader = subclass ( locale_path ) content : dict = loader . load ( locales ) sorted_content : dict = __sort_nested ( content ) __save_normalized ( locales , loader , locale_path , sorted_content )","title":"__perform_normalize()"},{"location":"code/tasks/#pyi18n.tasks.normalize.__save_normalized","text":"private function to save the normalized content, should not be called directly. Source code in pyi18n/tasks/normalize.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __save_normalized ( locales : set , loader : loaders . PyI18nBaseLoader , locale_path : str , sorted_content : dict ) -> None : \"\"\" private function to save the normalized content, should not be called directly.\"\"\" ext : str = loader . type () . replace ( 'yaml' , 'yml' ) dumper : str = { \"json\" : lambda x , y : json_dump ( x , y , indent = 4 , sort_keys = True ), \"yml\" : yaml_dump , \"xml\" : lambda x , _ : xml_dump ( x , pretty = True ) } for locale in locales : file_path : str = f \" { locale_path }{ locale } . { ext } \" with open ( file_path , \"w\" , encoding = \"utf-8\" ) as _f : dumper [ ext ]({ locale : sorted_content [ locale ]}, _f )","title":"__save_normalized()"},{"location":"code/tasks/#pyi18n.tasks.normalize.__sort_nested","text":"private function to sort nested dictionaries Source code in pyi18n/tasks/normalize.py 73 74 75 def __sort_nested ( dictionary : dict ) -> dict : \"\"\" private function to sort nested dictionaries \"\"\" return { k : dict ( sorted ( v . items ())) for k , v in dictionary . items ()}","title":"__sort_nested()"},{"location":"code/tasks/#pyi18n.tasks.normalize.normalize_locales","text":"Sorts the keys in alphabetically order, and overrides files Source code in pyi18n/tasks/normalize.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def normalize_locales ( locale_path : str = \"locales/\" ) -> dict : \"\"\" Sorts the keys in alphabetically order, and overrides files \"\"\" locale_path : str = f \" { getcwd () } / { locale_path } \" if not exists ( locale_path ): print ( f \"[ERROR] { locale_path } does not exist\" ) exit ( 1 ) locales : set = set ([ x . split ( '.' )[ 0 ] for x in listdir ( locale_path )]) if not locales : print ( f \"[ERROR] { locale_path } is empty\" ) exit ( 1 ) __perform_normalize ( locales , locale_path )","title":"normalize_locales()"},{"location":"home/","text":"PyI18n PyI18n is a simple and easy to use internationalization library for Python, inspired by Ruby i18n. Documentation available at https://sectasy0.github.io/pyi18n . Installation You can install PyI18n via pip: pip install pyi18n-v2 Getting Started A few motivating and useful examples of how pyi18n can be used. To use PyI18n in your application, you will first need to create a locales folder in the root directory of your project. Within this folder, you can create locale files in the format of your choice (e.g. YAML, JSON). For example: $ mkdir -p my_app/locales $ touch my_app/locales/en.yml $ touch my_app/locales/pl.yml $ touch my_app/locales/de.yml You can then create an instance of the PyI18n class, passing in the desired languages and, optionally, a custom locales directory. from pyi18n import PyI18n # default load_path is locales/ # you can change this path by specifying load_path parameter i18n = PyI18n (( \"en\" , \"pl\" , \"de\" , \"jp\" ), load_path = \"translations/\" ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John! print ( _ ( \"pl\" , \"hello.hello_user\" , user = \"John\" )) #> Witaj John! print ( _ ( \"de\" , \"hello.hello_user\" , user = \"John\" )) #> Hallo John! print ( _ ( \"jp\" , \"hello.hello_user\" , user = \"\u30b8\u30e7\u30f3\u3055\u3093\" )) #> \u3053\u3093\u306b\u3061\u306f\u3001\u30b8\u30e7\u30f3\u3055\u3093\uff01 Integrate pyi18n with Django project To integrate pyi18n into your Django project, you will need to first add a locale field to your user model class. This field will store the user's preferred language, which will be used to retrieve the appropriate translations from the locales directory. Next, you will need to configure pyi18n in your settings.py file by creating an instance of the PyI18n class and specifying the available languages. You can also create a gettext function for ease of use. In your views, you can then use the gettext function to retrieve translations based on the user's preferred language. To use translations in templates, you will need to create a custom template tag that utilizes the gettext function. settings.py from pyi18n import PyI18n i18n : PyI18n = PyI18n ([ 'pl' , 'en' ]) _ : callable = i18n . gettext views.py from mysite.settings import _ def index ( request ): translated : str = _ ( request . user . locale , 'hello' , name = \"John\" ) return HttpResponse ( f \"This is an example view. { translated } \" ) register template tag from django import template from mysite.settings import _ register = template . Library () @register . filter ( name = 't' ) def translate ( locale : str , path : str , ** kwargs ): return _ ( locale , path , ** kwargs ) That's it, you have now successfully installed and configured PyI18n for your project. You can now use the provided gettext function to easily retrieve translations based on the user's preferred language. Additionally, you can use the provided template tag to easily retrieve translations in your templates. And if you need to use custom loaders you can use the PyI18nBaseLoader to create your own loaders. Creating custom loader class To create custom locale loader you have to create a class which will inherit from PyI18nBaseLoader and override load method with all required parameters (see below). You can see an example of custom locale loader in examples/custom_xml_loader.py . from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded # return a dictionary with locale data ... your custom loader logic ... return {} Then pass your custom loader to PyI18n class. from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded ... your custom loader logic ... # have to return a dictionary return {} # don't use load_path in `PyI18n` constructor, if not using default yaml loader if __name__ == \"__main__\" : load_path : str = \"locales/\" loader : PyI18nBaseLoader = MyCustomLoader ( load_path = load_path ) i18n : PyI18n = PyI18n (( \"en\" ,), loader = loader ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John! Tasks Tasks usage $ pyi18n-tasks usage: pyi18n-tasks [ -h ] [ -p PATH ] normalize pyi18n-tasks: error: the following arguments are required: normalize Normalization Normalization process will sort locales alphabetically. The default normalization path is locales/ , you can change it by passing -p argument. $ pyi18n-tasks normalize $ pyi18n-tasks normalize -p my_app/locales/ Run tests python3 tests/run_tests.py For any questions and suggestions or bugs please create an issue. Limitations Normalization task will not work for custom loader classes except xml, if you need that use one of build in loaders or user XML loader from example. Roadmap See issues, If I have enough time and come up with a good idea on how this package can be improved, I'll post it there, along with tip. Release History Release History available at https://sectasy0.github.io/pyi18n/home/release-history/ . Meta Distributed under the MIT license. See LICENSE for more information. https://github.com/sectasy0 Contributing Fork it ( https://github.com/sectasy0/pyi18n ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'feat: Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Home"},{"location":"home/#pyi18n","text":"PyI18n is a simple and easy to use internationalization library for Python, inspired by Ruby i18n. Documentation available at https://sectasy0.github.io/pyi18n .","title":"PyI18n"},{"location":"home/#installation","text":"You can install PyI18n via pip: pip install pyi18n-v2","title":"Installation"},{"location":"home/#getting-started","text":"A few motivating and useful examples of how pyi18n can be used. To use PyI18n in your application, you will first need to create a locales folder in the root directory of your project. Within this folder, you can create locale files in the format of your choice (e.g. YAML, JSON). For example: $ mkdir -p my_app/locales $ touch my_app/locales/en.yml $ touch my_app/locales/pl.yml $ touch my_app/locales/de.yml You can then create an instance of the PyI18n class, passing in the desired languages and, optionally, a custom locales directory. from pyi18n import PyI18n # default load_path is locales/ # you can change this path by specifying load_path parameter i18n = PyI18n (( \"en\" , \"pl\" , \"de\" , \"jp\" ), load_path = \"translations/\" ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John! print ( _ ( \"pl\" , \"hello.hello_user\" , user = \"John\" )) #> Witaj John! print ( _ ( \"de\" , \"hello.hello_user\" , user = \"John\" )) #> Hallo John! print ( _ ( \"jp\" , \"hello.hello_user\" , user = \"\u30b8\u30e7\u30f3\u3055\u3093\" )) #> \u3053\u3093\u306b\u3061\u306f\u3001\u30b8\u30e7\u30f3\u3055\u3093\uff01","title":"Getting Started"},{"location":"home/#integrate-pyi18n-with-django-project","text":"To integrate pyi18n into your Django project, you will need to first add a locale field to your user model class. This field will store the user's preferred language, which will be used to retrieve the appropriate translations from the locales directory. Next, you will need to configure pyi18n in your settings.py file by creating an instance of the PyI18n class and specifying the available languages. You can also create a gettext function for ease of use. In your views, you can then use the gettext function to retrieve translations based on the user's preferred language. To use translations in templates, you will need to create a custom template tag that utilizes the gettext function.","title":"Integrate pyi18n with Django project"},{"location":"home/#settingspy","text":"from pyi18n import PyI18n i18n : PyI18n = PyI18n ([ 'pl' , 'en' ]) _ : callable = i18n . gettext","title":"settings.py"},{"location":"home/#viewspy","text":"from mysite.settings import _ def index ( request ): translated : str = _ ( request . user . locale , 'hello' , name = \"John\" ) return HttpResponse ( f \"This is an example view. { translated } \" )","title":"views.py"},{"location":"home/#register-template-tag","text":"from django import template from mysite.settings import _ register = template . Library () @register . filter ( name = 't' ) def translate ( locale : str , path : str , ** kwargs ): return _ ( locale , path , ** kwargs ) That's it, you have now successfully installed and configured PyI18n for your project. You can now use the provided gettext function to easily retrieve translations based on the user's preferred language. Additionally, you can use the provided template tag to easily retrieve translations in your templates. And if you need to use custom loaders you can use the PyI18nBaseLoader to create your own loaders.","title":"register template tag"},{"location":"home/#creating-custom-loader-class","text":"To create custom locale loader you have to create a class which will inherit from PyI18nBaseLoader and override load method with all required parameters (see below). You can see an example of custom locale loader in examples/custom_xml_loader.py . from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded # return a dictionary with locale data ... your custom loader logic ... return {} Then pass your custom loader to PyI18n class. from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded ... your custom loader logic ... # have to return a dictionary return {} # don't use load_path in `PyI18n` constructor, if not using default yaml loader if __name__ == \"__main__\" : load_path : str = \"locales/\" loader : PyI18nBaseLoader = MyCustomLoader ( load_path = load_path ) i18n : PyI18n = PyI18n (( \"en\" ,), loader = loader ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John!","title":"Creating custom loader class"},{"location":"home/#tasks","text":"","title":"Tasks"},{"location":"home/#tasks-usage","text":"$ pyi18n-tasks usage: pyi18n-tasks [ -h ] [ -p PATH ] normalize pyi18n-tasks: error: the following arguments are required: normalize","title":"Tasks usage"},{"location":"home/#normalization","text":"Normalization process will sort locales alphabetically. The default normalization path is locales/ , you can change it by passing -p argument. $ pyi18n-tasks normalize $ pyi18n-tasks normalize -p my_app/locales/","title":"Normalization"},{"location":"home/#run-tests","text":"python3 tests/run_tests.py For any questions and suggestions or bugs please create an issue.","title":"Run tests"},{"location":"home/#limitations","text":"Normalization task will not work for custom loader classes except xml, if you need that use one of build in loaders or user XML loader from example.","title":"Limitations"},{"location":"home/#roadmap","text":"See issues, If I have enough time and come up with a good idea on how this package can be improved, I'll post it there, along with tip.","title":"Roadmap"},{"location":"home/#release-history","text":"Release History available at https://sectasy0.github.io/pyi18n/home/release-history/ .","title":"Release History"},{"location":"home/#meta","text":"Distributed under the MIT license. See LICENSE for more information. https://github.com/sectasy0","title":"Meta"},{"location":"home/#contributing","text":"Fork it ( https://github.com/sectasy0/pyi18n ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'feat: Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Contributing"},{"location":"home/contributing/","text":"Current todo list Remove duplicates during normalization Translation for pyi18n-tasks from multiple sources Adding new locale from pyi18n-tasks Help us improve this project Fork it ( https://github.com/sectasy0/pyi18n ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'feat: Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Contributing"},{"location":"home/contributing/#current-todo-list","text":"Remove duplicates during normalization Translation for pyi18n-tasks from multiple sources Adding new locale from pyi18n-tasks","title":"Current todo list"},{"location":"home/contributing/#help-us-improve-this-project","text":"Fork it ( https://github.com/sectasy0/pyi18n ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'feat: Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Help us improve this project"},{"location":"home/license/","text":"MIT License Copyright \u00a9 2022 sectasy0 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"home/release-history/","text":"Unreleased Enhancements: Implemented guidelines for integration with the Django framework. Refactored the tasks/normalize.py __sort_nested method for improved efficiency. Revised the PyI18n class constructor for better readability and maintainability. Resolved flake8 errors to ensure code adheres to the pep8 standard. Version 1.1.0 - 23.08.2022 New Features: Introduced the normalize task for improved organization. Added the ability to run the normalize task through command-line interface. Version 1.0.0 - 2022-08-12 Initial release.","title":"Release History"},{"location":"home/release-history/#unreleased","text":"Enhancements: Implemented guidelines for integration with the Django framework. Refactored the tasks/normalize.py __sort_nested method for improved efficiency. Revised the PyI18n class constructor for better readability and maintainability. Resolved flake8 errors to ensure code adheres to the pep8 standard.","title":"Unreleased"},{"location":"home/release-history/#version-110-23082022","text":"New Features: Introduced the normalize task for improved organization. Added the ability to run the normalize task through command-line interface.","title":"Version 1.1.0 - 23.08.2022"},{"location":"home/release-history/#version-100-2022-08-12","text":"Initial release.","title":"Version 1.0.0 - 2022-08-12"},{"location":"started/basic-usage/","text":"Using PyI18n in your application is pretty easy, all you need to do before is create your locale files. Info By default PyI18n will look for your locale files in ./locale directory. Create loacle files You can create as many files as you need for the languages in your application, PyI18n will handle it. $ mkdir locale $ touch locale/en.yml $ touch locale/pl.yml Those files have to be in YAML format, for e.g. you're creating online shop Example pl locale file pl : labels : products : Produkty cart : Koszyk checkout : Z\u0142\u00f3\u017c zam\u00f3wienie messages : cart : empty : Koszyk jest pusty total : \"\u0141\u0105cznie: {total}\" checkout : title : Z\u0142\u00f3\u017c zam\u00f3wienie name : Imi\u0119 surname : Nazwisko email : Email phone : Telefon address : Adres city : Miasto zip : Kod pocztowy country : Kraj payment : Metoda p\u0142atno\u015bci payment_method_card : Karta payment_method_cash : Got\u00f3wka payment_method_transfer : Przelew payment_method_paypal : PayPal payment_method_other : Inne payment_method_other_description : Opis p\u0142atno\u015bci Example en locale file en : labels : products : Products cart : Cart checkout : Checkout messages : cart : empty : Cart is empty total : \"Total: {total}\" checkout : title : Checkout name : Name surname : Surname email : Email phone : Phone address : Address city : City zip : Zip country : Country payment : Payment method payment_method_card : Card payment_method_cash : Cash payment_method_transfer : Transfer payment_method_paypal : PayPal payment_method_other : Other payment_method_other_description : Payment method description Integrate with your application Application structure . \u251c\u2500\u2500 locales \u2502 \u251c\u2500\u2500 en.yml \u2502 \u2514\u2500\u2500 pl.yml \u2514\u2500\u2500 store.py products = { '1' : { 'name' : 'Chocolate' , 'price' : '$2.00' , 'description' : 'A delicious chocolate' , }, '2' : { 'name' : 'Coffee' , 'price' : '$3.00' , 'description' : 'A delicious coffee' , }, '3' : { 'name' : 'Tea' , 'price' : '$1.00' , 'description' : 'A delicious tea' , }, } if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) user_locale : str = input ( 'Enter your locale: ' ) if user_locale . lower () not in available_locales : print ( 'Locale not supported, please select another one' ) sys . exit ( 1 ) i18n : PyI18n = PyI18n ( available_locales ) _ = i18n . gettext print ( _ ( user_locale , 'messages.welcome' )) print ( \"============================\" ) print ( _ ( user_locale , 'labels.products' ) + \": \\n \" ) if not products : print ( _ ( user_locale , 'messages.product_list.empty' )) else : for product in products : print ( f \" { product } - { products [ product ][ 'name' ] } - { products [ product ][ 'price' ] } \" ) Json format files Lets take a look at the example above, we can use json format files as well. Info In this example we're using PyI18nJsonLoader to load translations from translations/ directory. Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. from pyi18n import PyI18n from pyi18n.loaders import PyI18nJsonLoader if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) loader : PyI18nJsonLoader = PyI18nJsonLoader ( 'translations/' ) i18n : PyI18n = PyI18n ( available_locales , loader = loader ) _ = i18n . gettext","title":"Basic usage"},{"location":"started/basic-usage/#create-loacle-files","text":"You can create as many files as you need for the languages in your application, PyI18n will handle it. $ mkdir locale $ touch locale/en.yml $ touch locale/pl.yml Those files have to be in YAML format, for e.g. you're creating online shop Example pl locale file pl : labels : products : Produkty cart : Koszyk checkout : Z\u0142\u00f3\u017c zam\u00f3wienie messages : cart : empty : Koszyk jest pusty total : \"\u0141\u0105cznie: {total}\" checkout : title : Z\u0142\u00f3\u017c zam\u00f3wienie name : Imi\u0119 surname : Nazwisko email : Email phone : Telefon address : Adres city : Miasto zip : Kod pocztowy country : Kraj payment : Metoda p\u0142atno\u015bci payment_method_card : Karta payment_method_cash : Got\u00f3wka payment_method_transfer : Przelew payment_method_paypal : PayPal payment_method_other : Inne payment_method_other_description : Opis p\u0142atno\u015bci Example en locale file en : labels : products : Products cart : Cart checkout : Checkout messages : cart : empty : Cart is empty total : \"Total: {total}\" checkout : title : Checkout name : Name surname : Surname email : Email phone : Phone address : Address city : City zip : Zip country : Country payment : Payment method payment_method_card : Card payment_method_cash : Cash payment_method_transfer : Transfer payment_method_paypal : PayPal payment_method_other : Other payment_method_other_description : Payment method description","title":"Create loacle files"},{"location":"started/basic-usage/#integrate-with-your-application","text":"Application structure . \u251c\u2500\u2500 locales \u2502 \u251c\u2500\u2500 en.yml \u2502 \u2514\u2500\u2500 pl.yml \u2514\u2500\u2500 store.py products = { '1' : { 'name' : 'Chocolate' , 'price' : '$2.00' , 'description' : 'A delicious chocolate' , }, '2' : { 'name' : 'Coffee' , 'price' : '$3.00' , 'description' : 'A delicious coffee' , }, '3' : { 'name' : 'Tea' , 'price' : '$1.00' , 'description' : 'A delicious tea' , }, } if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) user_locale : str = input ( 'Enter your locale: ' ) if user_locale . lower () not in available_locales : print ( 'Locale not supported, please select another one' ) sys . exit ( 1 ) i18n : PyI18n = PyI18n ( available_locales ) _ = i18n . gettext print ( _ ( user_locale , 'messages.welcome' )) print ( \"============================\" ) print ( _ ( user_locale , 'labels.products' ) + \": \\n \" ) if not products : print ( _ ( user_locale , 'messages.product_list.empty' )) else : for product in products : print ( f \" { product } - { products [ product ][ 'name' ] } - { products [ product ][ 'price' ] } \" )","title":"Integrate with your application"},{"location":"started/basic-usage/#json-format-files","text":"Lets take a look at the example above, we can use json format files as well. Info In this example we're using PyI18nJsonLoader to load translations from translations/ directory. Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. from pyi18n import PyI18n from pyi18n.loaders import PyI18nJsonLoader if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) loader : PyI18nJsonLoader = PyI18nJsonLoader ( 'translations/' ) i18n : PyI18n = PyI18n ( available_locales , loader = loader ) _ = i18n . gettext","title":"Json format files"},{"location":"started/custom-loader/","text":"Writing a custom loader with an example of a loader for XML file format. To create your own loader, you have to inherit from PyI18nBaseLoader class and implement load method. Note Your custom loader load method should return dictionary with translations otherwise your loader will not work. class PyI18nXMLLoader ( PyI18nBaseLoader ): _type : str = \"xml\" # type of loader def load ( self , locales : tuple ) -> dict : # XML loader logic loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } .xml\" if not exists ( file_path ): continue with open ( file_path , \"r\" , encoding = \"utf-8\" ) as _f : loaded [ locale ] = parse ( _f . read ())[ locale ] return loaded Pass custom loader to PyI18n constructor Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. if __name__ == \"__main__\" : loader : PyI18nXMLLoader = PyI18nXMLLoader ( \"locales/\" ) i18n : PyI18n = PyI18n (( 'en' , 'pl' ), loader = loader ) print ( i18n . gettext ( \"en\" , \"hello.world\" )) print ( i18n . gettext ( \"pl\" , \"hello.world\" )) # >> Hello world! # >> Witaj \u015bwiecie!","title":"Custom loader"},{"location":"started/custom-loader/#pass-custom-loader-to-pyi18n-constructor","text":"Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. if __name__ == \"__main__\" : loader : PyI18nXMLLoader = PyI18nXMLLoader ( \"locales/\" ) i18n : PyI18n = PyI18n (( 'en' , 'pl' ), loader = loader ) print ( i18n . gettext ( \"en\" , \"hello.world\" )) print ( i18n . gettext ( \"pl\" , \"hello.world\" )) # >> Hello world! # >> Witaj \u015bwiecie!","title":"Pass custom loader to PyI18n constructor"},{"location":"started/normalization/","text":"What is normalization? Normalization process will sort your locales in alphabetical order and will remove duplicates. Running normalization task python3 -m pyi18n-tasks normalize Custom path for normalization task python3 -m pyi18n-tasks normalize --path = translations/","title":"Normalize your locales"},{"location":"started/normalization/#running-normalization-task","text":"python3 -m pyi18n-tasks normalize","title":"Running normalization task"},{"location":"started/normalization/#custom-path-for-normalization-task","text":"python3 -m pyi18n-tasks normalize --path = translations/","title":"Custom path for normalization task"}]}