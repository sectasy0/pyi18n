{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Version 1.2.1 - 26.03.2023 Enhancements: Remove ugly hack to make tests work due to incorrect imports. Test coverage has been increased to 99%. Version 1.2.0 - 15.03.2023 New Features: Support for namespaces. Enhancements: Implemented guidelines for integration with the Django framework. Refactored the tasks/normalize.py __sort_nested method for improved efficiency. Revised the PyI18n class constructor for better readability and maintainability. Resolved flake8 errors to ensure code adheres to the pep8 standard. Version 1.1.0 - 23.08.2022 New Features: Introduced the normalize task for improved organization. Added the ability to run the normalize task through command-line interface. Version 1.0.0 - 2022-08-12 Initial release.","title":"Home"},{"location":"#version-121-26032023","text":"Enhancements: Remove ugly hack to make tests work due to incorrect imports. Test coverage has been increased to 99%.","title":"Version 1.2.1 - 26.03.2023"},{"location":"#version-120-15032023","text":"New Features: Support for namespaces. Enhancements: Implemented guidelines for integration with the Django framework. Refactored the tasks/normalize.py __sort_nested method for improved efficiency. Revised the PyI18n class constructor for better readability and maintainability. Resolved flake8 errors to ensure code adheres to the pep8 standard.","title":"Version 1.2.0 - 15.03.2023"},{"location":"#version-110-23082022","text":"New Features: Introduced the normalize task for improved organization. Added the ability to run the normalize task through command-line interface.","title":"Version 1.1.0 - 23.08.2022"},{"location":"#version-100-2022-08-12","text":"Initial release.","title":"Version 1.0.0 - 2022-08-12"},{"location":"support/","text":"Something will be here in future","title":"Support"},{"location":"code/helpers/","text":"Documentation for helpers module This module contains various helper functions and utilities that can be used throughout the application. get_files ( path , file_extension ) Get a list of files in a directory with a given file extension. Parameters: Name Type Description Default path str path to the directory required file_extension str file extension to search for (e.g. \".yml\") required Return List[str]: list of file names in the directory with the given extension Source code in pyi18n/helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_files ( path : str , file_extension : str ) -> List [ str ]: \"\"\"Get a list of files in a directory with a given file extension. Args: path (str): path to the directory file_extension (str): file extension to search for (e.g. \".yml\") Return: List[str]: list of file names in the directory with the given extension \"\"\" if not file_extension : return [] return [ file_name for file_name in listdir ( path ) if file_name . endswith ( file_extension )] load_file ( file_path , ser_mod , l_type ) Load translations from a single file. Parameters: Name Type Description Default file_path str path to the translation file required ser_mod object module for serialization required l_type str type of file to load (e.g. \"yaml\", \"json\") required Return dict: loaded translations from the file Source code in pyi18n/helpers.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def load_file ( file_path : str , ser_mod : object , l_type : str ) -> dict : \"\"\"Load translations from a single file. Args: file_path (str): path to the translation file ser_mod (object): module for serialization l_type (str): type of file to load (e.g. \"yaml\", \"json\") Return: dict: loaded translations from the file \"\"\" loader_params : dict = { 'Loader' : FullLoader } if l_type == 'yaml' else {} with open ( file_path , 'r' , encoding = 'utf-8' ) as file : return ser_mod . load ( file , ** loader_params ) load_locale ( path , ser_mod , l_type ) Load translations from a single locale directory. Parameters: Name Type Description Default path str path to the locale directory required ser_mod object module for serialization required Return dict: loaded translations for the locale Source code in pyi18n/helpers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_locale ( path : str , ser_mod : object , l_type : str ) -> dict : \"\"\"Load translations from a single locale directory. Args: path (str): path to the locale directory ser_mod (object): module for serialization Return: dict: loaded translations for the locale \"\"\" if not exists ( path ): print ( f \"[WARNING] path { path } doesn't exist, probably you forgot\" , \"to add it to the available locales list.\" ) return {} file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded_locale : dict = {} for file_name in get_files ( path , file_extension ): file_path : str = join ( path , file_name ) namespace : str = splitext ( file_name )[ 0 ] if not stat ( file_path ) . st_size : continue locale_content = load_file ( file_path , ser_mod , l_type ) loaded_locale [ namespace ] = locale_content return loaded_locale","title":"Documentation for `helpers` module"},{"location":"code/helpers/#documentation-for-helpers-module","text":"This module contains various helper functions and utilities that can be used throughout the application.","title":"Documentation for helpers module"},{"location":"code/helpers/#pyi18n.helpers.get_files","text":"Get a list of files in a directory with a given file extension. Parameters: Name Type Description Default path str path to the directory required file_extension str file extension to search for (e.g. \".yml\") required Return List[str]: list of file names in the directory with the given extension Source code in pyi18n/helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def get_files ( path : str , file_extension : str ) -> List [ str ]: \"\"\"Get a list of files in a directory with a given file extension. Args: path (str): path to the directory file_extension (str): file extension to search for (e.g. \".yml\") Return: List[str]: list of file names in the directory with the given extension \"\"\" if not file_extension : return [] return [ file_name for file_name in listdir ( path ) if file_name . endswith ( file_extension )]","title":"get_files()"},{"location":"code/helpers/#pyi18n.helpers.load_file","text":"Load translations from a single file. Parameters: Name Type Description Default file_path str path to the translation file required ser_mod object module for serialization required l_type str type of file to load (e.g. \"yaml\", \"json\") required Return dict: loaded translations from the file Source code in pyi18n/helpers.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def load_file ( file_path : str , ser_mod : object , l_type : str ) -> dict : \"\"\"Load translations from a single file. Args: file_path (str): path to the translation file ser_mod (object): module for serialization l_type (str): type of file to load (e.g. \"yaml\", \"json\") Return: dict: loaded translations from the file \"\"\" loader_params : dict = { 'Loader' : FullLoader } if l_type == 'yaml' else {} with open ( file_path , 'r' , encoding = 'utf-8' ) as file : return ser_mod . load ( file , ** loader_params )","title":"load_file()"},{"location":"code/helpers/#pyi18n.helpers.load_locale","text":"Load translations from a single locale directory. Parameters: Name Type Description Default path str path to the locale directory required ser_mod object module for serialization required Return dict: loaded translations for the locale Source code in pyi18n/helpers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_locale ( path : str , ser_mod : object , l_type : str ) -> dict : \"\"\"Load translations from a single locale directory. Args: path (str): path to the locale directory ser_mod (object): module for serialization Return: dict: loaded translations for the locale \"\"\" if not exists ( path ): print ( f \"[WARNING] path { path } doesn't exist, probably you forgot\" , \"to add it to the available locales list.\" ) return {} file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded_locale : dict = {} for file_name in get_files ( path , file_extension ): file_path : str = join ( path , file_name ) namespace : str = splitext ( file_name )[ 0 ] if not stat ( file_path ) . st_size : continue locale_content = load_file ( file_path , ser_mod , l_type ) loaded_locale [ namespace ] = locale_content return loaded_locale","title":"load_locale()"},{"location":"code/loaders/","text":"Documentation for loaders module This module defines the PyI18n loaders which load translations from files in YAML or JSON format. LoaderType Enum for the different loader types. Source code in pyi18n/loaders.py 14 15 16 17 18 class LoaderType : \"\"\" Enum for the different loader types. \"\"\" BASE : str = \"base\" YAML : str = \"yaml\" JSON : str = \"json\" PyI18nBaseLoader PyI18n Base Loader class, supports yaml and json Attributes: Name Type Description load_path str path to translations namespaced bool tells loader should look for namespaces _type str loader type Source code in pyi18n/loaders.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class PyI18nBaseLoader : \"\"\" PyI18n Base Loader class, supports yaml and json Attributes: load_path (str): path to translations namespaced (bool): tells loader should look for namespaces _type (str): loader type \"\"\" _type : str = LoaderType . BASE def __init__ ( self , load_path : str = \"locales/\" , namespaced : bool = False ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations namespaced (bool): namespaces support Return: None \"\"\" self . load_path : str = load_path self . namespaced : bool = namespaced def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Return: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Return: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ] def _load_namespaced ( self , locales : tuple , ser_mod : Any ) -> dict : \"\"\"Load translations from namespaces. Should be overridden in child classes. This will look for a locale (directories) and load all namespaces. Args: locales (tuple): locales to load ser_mod (object): module for serialization Return: dict: loaded translations \"\"\" loaded : dict = {} for locale in locales : path : str = join ( self . load_path , locale ) loaded_locale : dict = load_locale ( path , ser_mod , self . _type ) if not loaded_locale : continue loaded . setdefault ( locale , loaded_locale ) return loaded def type ( self ) -> str : \"\"\" Return loader type Return: str: loader type \"\"\" return self . _type def get_path ( self ) -> str : \"\"\" Return loader path Return: str: loader path \"\"\" return self . load_path __init__ ( load_path = 'locales/' , namespaced = False ) Initialize loader class Parameters: Name Type Description Default load_path str path to translations 'locales/' namespaced bool namespaces support False Return None Source code in pyi18n/loaders.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , load_path : str = \"locales/\" , namespaced : bool = False ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations namespaced (bool): namespaces support Return: None \"\"\" self . load_path : str = load_path self . namespaced : bool = namespaced __load_file ( file_path , ext , ser_mod , locale ) loads content, should not be called directly Return dict: loaded content Source code in pyi18n/loaders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Return: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ] get_path () Return loader path Return str: loader path Source code in pyi18n/loaders.py 135 136 137 138 139 140 141 def get_path ( self ) -> str : \"\"\" Return loader path Return: str: loader path \"\"\" return self . load_path load ( locales , ser_mod ) Load translations for given locales, should be overridden in child classes. Parameters: Name Type Description Default locales tuple locales to load required Return dict: loaded translations Notes Custom load function should be implemented in child classes and return python dict Source code in pyi18n/loaders.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Return: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded type () Return loader type Return str: loader type Source code in pyi18n/loaders.py 127 128 129 130 131 132 133 def type ( self ) -> str : \"\"\" Return loader type Return: str: loader type \"\"\" return self . _type PyI18nJsonLoader Bases: PyI18nBaseLoader PyI18n JSON Loader class Attributes: Name Type Description load_path str path to translations namespaced bool tells loader should look for namespaces _type str loader type Source code in pyi18n/loaders.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class PyI18nJsonLoader ( PyI18nBaseLoader ): \"\"\" PyI18n JSON Loader class Attributes: load_path (str): path to translations namespaced (bool): tells loader should look for namespaces _type (str): loader type \"\"\" _type : str = LoaderType . JSON def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , json ) return super () . load ( locales , json ) load ( locales ) Load translations for given locales using json Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Return dict: loaded translations Source code in pyi18n/loaders.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , json ) return super () . load ( locales , json ) PyI18nYamlLoader Bases: PyI18nBaseLoader PyI18n YAML Loader class Attributes: Name Type Description load_path str path to translations namespaced bool tells loader should look for namespaces _type str loader type Source code in pyi18n/loaders.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class PyI18nYamlLoader ( PyI18nBaseLoader ): \"\"\" PyI18n YAML Loader class Attributes: load_path (str): path to translations namespaced (bool): tells loader should look for namespaces _type (str): loader type \"\"\" _type : str = LoaderType . YAML def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , yaml ) return super () . load ( locales , yaml ) load ( locales ) Load translations for given locales using yaml Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Return dict: loaded translations Source code in pyi18n/loaders.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , yaml ) return super () . load ( locales , yaml )","title":"Loaders"},{"location":"code/loaders/#documentation-for-loaders-module","text":"This module defines the PyI18n loaders which load translations from files in YAML or JSON format.","title":"Documentation for loaders module"},{"location":"code/loaders/#pyi18n.loaders.LoaderType","text":"Enum for the different loader types. Source code in pyi18n/loaders.py 14 15 16 17 18 class LoaderType : \"\"\" Enum for the different loader types. \"\"\" BASE : str = \"base\" YAML : str = \"yaml\" JSON : str = \"json\"","title":"LoaderType"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader","text":"PyI18n Base Loader class, supports yaml and json Attributes: Name Type Description load_path str path to translations namespaced bool tells loader should look for namespaces _type str loader type Source code in pyi18n/loaders.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class PyI18nBaseLoader : \"\"\" PyI18n Base Loader class, supports yaml and json Attributes: load_path (str): path to translations namespaced (bool): tells loader should look for namespaces _type (str): loader type \"\"\" _type : str = LoaderType . BASE def __init__ ( self , load_path : str = \"locales/\" , namespaced : bool = False ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations namespaced (bool): namespaces support Return: None \"\"\" self . load_path : str = load_path self . namespaced : bool = namespaced def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Return: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Return: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ] def _load_namespaced ( self , locales : tuple , ser_mod : Any ) -> dict : \"\"\"Load translations from namespaces. Should be overridden in child classes. This will look for a locale (directories) and load all namespaces. Args: locales (tuple): locales to load ser_mod (object): module for serialization Return: dict: loaded translations \"\"\" loaded : dict = {} for locale in locales : path : str = join ( self . load_path , locale ) loaded_locale : dict = load_locale ( path , ser_mod , self . _type ) if not loaded_locale : continue loaded . setdefault ( locale , loaded_locale ) return loaded def type ( self ) -> str : \"\"\" Return loader type Return: str: loader type \"\"\" return self . _type def get_path ( self ) -> str : \"\"\" Return loader path Return: str: loader path \"\"\" return self . load_path","title":"PyI18nBaseLoader"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.__init__","text":"Initialize loader class Parameters: Name Type Description Default load_path str path to translations 'locales/' namespaced bool namespaces support False Return None Source code in pyi18n/loaders.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , load_path : str = \"locales/\" , namespaced : bool = False ) -> None : \"\"\" Initialize loader class Args: load_path (str): path to translations namespaced (bool): namespaces support Return: None \"\"\" self . load_path : str = load_path self . namespaced : bool = namespaced","title":"__init__()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.__load_file","text":"loads content, should not be called directly Return dict: loaded content Source code in pyi18n/loaders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def __load_file ( self , file_path : str , ext : str , ser_mod : object , locale : str ) -> dict : \"\"\" loads content, should not be called directly Return: dict: loaded content \"\"\" with open ( file_path , 'r' , encoding = \"utf-8\" ) as _f : load_params : dict = { \"Loader\" : yaml . FullLoader } \\ if ext == \"yml\" else {} return ser_mod . load ( _f , ** load_params )[ locale ]","title":"__load_file()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.get_path","text":"Return loader path Return str: loader path Source code in pyi18n/loaders.py 135 136 137 138 139 140 141 def get_path ( self ) -> str : \"\"\" Return loader path Return: str: loader path \"\"\" return self . load_path","title":"get_path()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.load","text":"Load translations for given locales, should be overridden in child classes. Parameters: Name Type Description Default locales tuple locales to load required Return dict: loaded translations Notes Custom load function should be implemented in child classes and return python dict Source code in pyi18n/loaders.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def load ( self , locales : tuple , ser_mod : object ) -> dict : \"\"\" Load translations for given locales, should be overridden in child classes. Args: locales (tuple): locales to load Return: dict: loaded translations Notes: Custom load function should be implemented in child classes and return python dict \"\"\" file_extension : str = ser_mod . __name__ . replace ( 'yaml' , 'yml' ) loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } . { file_extension } \" if not exists ( file_path ): continue try : loaded [ locale ] = self . __load_file ( file_path , file_extension , ser_mod , locale ) except ( json . decoder . JSONDecodeError , yaml . YAMLError ): continue return loaded","title":"load()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nBaseLoader.type","text":"Return loader type Return str: loader type Source code in pyi18n/loaders.py 127 128 129 130 131 132 133 def type ( self ) -> str : \"\"\" Return loader type Return: str: loader type \"\"\" return self . _type","title":"type()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nJsonLoader","text":"Bases: PyI18nBaseLoader PyI18n JSON Loader class Attributes: Name Type Description load_path str path to translations namespaced bool tells loader should look for namespaces _type str loader type Source code in pyi18n/loaders.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class PyI18nJsonLoader ( PyI18nBaseLoader ): \"\"\" PyI18n JSON Loader class Attributes: load_path (str): path to translations namespaced (bool): tells loader should look for namespaces _type (str): loader type \"\"\" _type : str = LoaderType . JSON def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , json ) return super () . load ( locales , json )","title":"PyI18nJsonLoader"},{"location":"code/loaders/#pyi18n.loaders.PyI18nJsonLoader.load","text":"Load translations for given locales using json Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Return dict: loaded translations Source code in pyi18n/loaders.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using json Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , json ) return super () . load ( locales , json )","title":"load()"},{"location":"code/loaders/#pyi18n.loaders.PyI18nYamlLoader","text":"Bases: PyI18nBaseLoader PyI18n YAML Loader class Attributes: Name Type Description load_path str path to translations namespaced bool tells loader should look for namespaces _type str loader type Source code in pyi18n/loaders.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class PyI18nYamlLoader ( PyI18nBaseLoader ): \"\"\" PyI18n YAML Loader class Attributes: load_path (str): path to translations namespaced (bool): tells loader should look for namespaces _type (str): loader type \"\"\" _type : str = LoaderType . YAML def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , yaml ) return super () . load ( locales , yaml )","title":"PyI18nYamlLoader"},{"location":"code/loaders/#pyi18n.loaders.PyI18nYamlLoader.load","text":"Load translations for given locales using yaml Inherits from PyI18nBaseLoader Parameters: Name Type Description Default locales tuple locales to load required Return dict: loaded translations Source code in pyi18n/loaders.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def load ( self , locales : tuple ) -> dict : \"\"\" Load translations for given locales using yaml Inherits from PyI18nBaseLoader Args: locales (tuple): locales to load Return: dict: loaded translations \"\"\" if self . namespaced : return super () . _load_namespaced ( locales , yaml ) return super () . load ( locales , yaml )","title":"load()"},{"location":"code/pyi18n/","text":"Documentation for PyI18n class Main i18n localization class Attributes: Name Type Description available_locales tuple list of available locales load_path str path to locales directory _loaded_translations dict (class attribute) dictionary of loaded translations Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n (( \"en\" , \"jp\" ), \"locales/\" ) >>> pyi18n . gettext ( \"en\" , \"hello.world\" ) 'Hello, world!' >>> pyi18n . gettext ( \"jp\" , \"hello.world\" ) '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' Source code in pyi18n/pyi18n.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class PyI18n : \"\"\" Main i18n localization class Attributes: available_locales (tuple): list of available locales load_path (str): path to locales directory _loaded_translations (dict): (class attribute) dictionary of loaded translations Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n((\"en\", \"jp\"), \"locales/\") >>> pyi18n.gettext(\"en\", \"hello.world\") 'Hello, world!' >>> pyi18n.gettext(\"jp\", \"hello.world\") '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' \"\"\" _loaded_translations : dict = {} def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Return: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init () def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales ) def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \" def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader __find ( path , locale ) Find translation for given path and locale Parameters: Name Type Description Default path str path to translation required locale str locale to get translation for required Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Source code in pyi18n/pyi18n.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \" __init__ ( available_locales , load_path = 'locales/' , loader = None ) Initialize i18n class Parameters: Name Type Description Default available_locales tuple list of available locales required load_path str path to locales directory 'locales/' Return None Source code in pyi18n/pyi18n.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Return: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init () __pyi18n_init () validator and loader for translations Raises: Type Description ValueError if locale is not available in self.available_locales FileNotFoundError if translation file is not found Source code in pyi18n/pyi18n.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales ) get_loader () Return loader class Returns: Name Type Description PyI18nBaseLoader PyI18nBaseLoader loader class Source code in pyi18n/pyi18n.py 129 130 131 132 133 134 135 136 def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader gettext ( locale , path , ** kwargs ) Get translation for given locale and path Parameters: Name Type Description Default locale str locale to get translation for required path str path to translation required **kwargs dict interpolation variables {} Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Raises: Type Description ValueError if locale is not in self.available_locales Source code in pyi18n/pyi18n.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded","title":"PyI18n class"},{"location":"code/pyi18n/#documentation-for-pyi18n-class","text":"Main i18n localization class Attributes: Name Type Description available_locales tuple list of available locales load_path str path to locales directory _loaded_translations dict (class attribute) dictionary of loaded translations Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n (( \"en\" , \"jp\" ), \"locales/\" ) >>> pyi18n . gettext ( \"en\" , \"hello.world\" ) 'Hello, world!' >>> pyi18n . gettext ( \"jp\" , \"hello.world\" ) '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' Source code in pyi18n/pyi18n.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class PyI18n : \"\"\" Main i18n localization class Attributes: available_locales (tuple): list of available locales load_path (str): path to locales directory _loaded_translations (dict): (class attribute) dictionary of loaded translations Examples: >>> from pyi18n import PyI18n >>> pyi18n = PyI18n((\"en\", \"jp\"), \"locales/\") >>> pyi18n.gettext(\"en\", \"hello.world\") 'Hello, world!' >>> pyi18n.gettext(\"jp\", \"hello.world\") '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01' \"\"\" _loaded_translations : dict = {} def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Return: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init () def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales ) def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \" def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader","title":"Documentation for PyI18n class"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.__find","text":"Find translation for given path and locale Parameters: Name Type Description Default path str path to translation required locale str locale to get translation for required Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Source code in pyi18n/pyi18n.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def __find ( self , path : str , locale : str ) -> Union [ dict , str ]: \"\"\" Find translation for given path and locale Args: path (str): path to translation locale (str): locale to get translation for Returns: Union[dict, str]: translation str, dict or error message \"\"\" try : return reduce ( getitem , path . split ( '.' ), self . _loaded_translations [ locale ]) except ( KeyError , TypeError ): return f \"missing translation for: { locale } . { path } \"","title":"__find()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.__init__","text":"Initialize i18n class Parameters: Name Type Description Default available_locales tuple list of available locales required load_path str path to locales directory 'locales/' Return None Source code in pyi18n/pyi18n.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , available_locales : tuple , load_path : str = \"locales/\" , loader : PyI18nBaseLoader = None ) -> None : \"\"\" Initialize i18n class Args: available_locales (tuple): list of available locales load_path (str): path to locales directory Return: None \"\"\" self . available_locales : tuple = available_locales self . load_path : str = f \" { getcwd () } / { load_path } \" self . loader : PyI18nBaseLoader = loader or PyI18nYamlLoader ( self . load_path ) self . load_path : str = self . loader . get_path () if self . loader . get_path ( ) != self . load_path else self . load_path self . __pyi18n_init ()","title":"__init__()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.__pyi18n_init","text":"validator and loader for translations Raises: Type Description ValueError if locale is not available in self.available_locales FileNotFoundError if translation file is not found Source code in pyi18n/pyi18n.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __pyi18n_init ( self ) -> None : \"\"\" validator and loader for translations Raises: ValueError: if locale is not available in self.available_locales FileNotFoundError: if translation file is not found \"\"\" if not self . available_locales : raise ValueError ( \"available locales must be specified\" ) if not exists ( self . load_path ): raise FileNotFoundError ( f \" { self . load_path } directory \" \"not found, please create it\" ) self . _loaded_translations : dict = self . loader . load ( self . available_locales )","title":"__pyi18n_init()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.get_loader","text":"Return loader class Returns: Name Type Description PyI18nBaseLoader PyI18nBaseLoader loader class Source code in pyi18n/pyi18n.py 129 130 131 132 133 134 135 136 def get_loader ( self ) -> PyI18nBaseLoader : \"\"\" Return loader class Returns: PyI18nBaseLoader: loader class \"\"\" return self . loader","title":"get_loader()"},{"location":"code/pyi18n/#pyi18n.pyi18n.PyI18n.gettext","text":"Get translation for given locale and path Parameters: Name Type Description Default locale str locale to get translation for required path str path to translation required **kwargs dict interpolation variables {} Returns: Type Description Union [ dict , str ] Union[dict, str]: translation str, dict or error message Raises: Type Description ValueError if locale is not in self.available_locales Source code in pyi18n/pyi18n.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def gettext ( self , locale : str , path : str , ** kwargs ) -> Union [ dict , str ]: \"\"\" Get translation for given locale and path Args: locale (str): locale to get translation for path (str): path to translation **kwargs (dict): interpolation variables Returns: Union[dict, str]: translation str, dict or error message Raises: ValueError: if locale is not in self.available_locales \"\"\" if locale not in self . available_locales : raise ValueError ( f \"locale { locale } not specified \" \"in available locales\" ) founded : Union [ dict , str ] = self . __find ( path , locale ) if len ( kwargs ) > 0 and isinstance ( founded , str ): try : return founded . format_map ( defaultdict ( str , ** kwargs )) except KeyError : return founded return founded","title":"gettext()"},{"location":"code/tasks/","text":"Documentation for tasks module normalize.py This module contains functions for normalizing i18n localization files. __perform_normalize ( locales , locale_path ) private method to perform normalization, should not be called directly Source code in pyi18n/tasks/normalize.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __perform_normalize ( locales : set , locale_path : str ) -> None : \"\"\" private method to perform normalization, should not be called directly\"\"\" for subclass in loaders . PyI18nBaseLoader . __subclasses__ (): if subclass . __name__ == \"PyI18nXMLLoader\" \\ and environ [ \"PYI18N_TEST_ENV\" ]: continue loader : loaders . PyI18nBaseLoader = subclass ( locale_path ) content : dict = loader . load ( locales ) sorted_content : dict = __sort_nested ( content ) __save_normalized ( locales , loader , locale_path , sorted_content ) __save_normalized ( locales , loader , locale_path , sorted_content ) private function to save the normalized content, should not be called directly. Source code in pyi18n/tasks/normalize.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __save_normalized ( locales : set , loader : loaders . PyI18nBaseLoader , locale_path : str , sorted_content : dict ) -> None : \"\"\" private function to save the normalized content, should not be called directly.\"\"\" ext : str = loader . type () . replace ( 'yaml' , 'yml' ) dumper : str = { \"json\" : lambda x , y : json_dump ( x , y , indent = 4 , sort_keys = True ), \"yml\" : yaml_dump , \"xml\" : lambda x , _ : xml_dump ( x , pretty = True ) } for locale in locales : file_path : str = f \" { locale_path }{ locale } . { ext } \" with open ( file_path , \"w\" , encoding = \"utf-8\" ) as _f : dumper [ ext ]({ locale : sorted_content [ locale ]}, _f ) __sort_nested ( dictionary ) private function to sort nested dictionaries Source code in pyi18n/tasks/normalize.py 73 74 75 def __sort_nested ( dictionary : dict ) -> dict : \"\"\" private function to sort nested dictionaries \"\"\" return { k : dict ( sorted ( v . items ())) for k , v in dictionary . items ()} normalize_locales ( locale_path = 'locales/' ) Sorts the keys in alphabetically order, and overrides files Source code in pyi18n/tasks/normalize.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def normalize_locales ( locale_path : str = \"locales/\" ) -> dict : \"\"\" Sorts the keys in alphabetically order, and overrides files \"\"\" locale_path : str = f \" { getcwd () } / { locale_path } \" if not exists ( locale_path ): print ( f \"[ERROR] { locale_path } does not exist\" ) exit ( 1 ) locales : set = set ([ x . split ( '.' )[ 0 ] for x in listdir ( locale_path )]) if not locales : print ( f \"[ERROR] { locale_path } is empty\" ) exit ( 1 ) __perform_normalize ( locales , locale_path )","title":"Tasks"},{"location":"code/tasks/#documentation-for-tasks-module","text":"","title":"Documentation for tasks module"},{"location":"code/tasks/#normalizepy","text":"This module contains functions for normalizing i18n localization files.","title":"normalize.py"},{"location":"code/tasks/#pyi18n.tasks.normalize.__perform_normalize","text":"private method to perform normalization, should not be called directly Source code in pyi18n/tasks/normalize.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __perform_normalize ( locales : set , locale_path : str ) -> None : \"\"\" private method to perform normalization, should not be called directly\"\"\" for subclass in loaders . PyI18nBaseLoader . __subclasses__ (): if subclass . __name__ == \"PyI18nXMLLoader\" \\ and environ [ \"PYI18N_TEST_ENV\" ]: continue loader : loaders . PyI18nBaseLoader = subclass ( locale_path ) content : dict = loader . load ( locales ) sorted_content : dict = __sort_nested ( content ) __save_normalized ( locales , loader , locale_path , sorted_content )","title":"__perform_normalize()"},{"location":"code/tasks/#pyi18n.tasks.normalize.__save_normalized","text":"private function to save the normalized content, should not be called directly. Source code in pyi18n/tasks/normalize.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __save_normalized ( locales : set , loader : loaders . PyI18nBaseLoader , locale_path : str , sorted_content : dict ) -> None : \"\"\" private function to save the normalized content, should not be called directly.\"\"\" ext : str = loader . type () . replace ( 'yaml' , 'yml' ) dumper : str = { \"json\" : lambda x , y : json_dump ( x , y , indent = 4 , sort_keys = True ), \"yml\" : yaml_dump , \"xml\" : lambda x , _ : xml_dump ( x , pretty = True ) } for locale in locales : file_path : str = f \" { locale_path }{ locale } . { ext } \" with open ( file_path , \"w\" , encoding = \"utf-8\" ) as _f : dumper [ ext ]({ locale : sorted_content [ locale ]}, _f )","title":"__save_normalized()"},{"location":"code/tasks/#pyi18n.tasks.normalize.__sort_nested","text":"private function to sort nested dictionaries Source code in pyi18n/tasks/normalize.py 73 74 75 def __sort_nested ( dictionary : dict ) -> dict : \"\"\" private function to sort nested dictionaries \"\"\" return { k : dict ( sorted ( v . items ())) for k , v in dictionary . items ()}","title":"__sort_nested()"},{"location":"code/tasks/#pyi18n.tasks.normalize.normalize_locales","text":"Sorts the keys in alphabetically order, and overrides files Source code in pyi18n/tasks/normalize.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def normalize_locales ( locale_path : str = \"locales/\" ) -> dict : \"\"\" Sorts the keys in alphabetically order, and overrides files \"\"\" locale_path : str = f \" { getcwd () } / { locale_path } \" if not exists ( locale_path ): print ( f \"[ERROR] { locale_path } does not exist\" ) exit ( 1 ) locales : set = set ([ x . split ( '.' )[ 0 ] for x in listdir ( locale_path )]) if not locales : print ( f \"[ERROR] { locale_path } is empty\" ) exit ( 1 ) __perform_normalize ( locales , locale_path )","title":"normalize_locales()"},{"location":"home/","text":"PyI18n PyI18n is a simple and easy to use internationalization library for Python, inspired by Ruby i18n. Documentation available at https://sectasy0.github.io/pyi18n . Installation You can install PyI18n via pip: pip install pyi18n-v2 Getting Started A few motivating and useful examples of how pyi18n can be used. To use PyI18n in your application, you will first need to create a locales folder in the root directory of your project. Within this folder, you can create locale files in the format of your choice (e.g. YAML, JSON). For example: $ mkdir -p my_app/locales $ touch my_app/locales/en.yml $ touch my_app/locales/pl.yml $ touch my_app/locales/de.yml You can then create an instance of the PyI18n class, passing in the desired languages and, optionally, a custom locales directory. from pyi18n import PyI18n # default load_path is locales/ # you can change this path by specifying load_path parameter i18n = PyI18n (( \"en\" , \"pl\" , \"de\" , \"jp\" ), load_path = \"translations/\" ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John! print ( _ ( \"pl\" , \"hello.hello_user\" , user = \"John\" )) #> Witaj John! print ( _ ( \"de\" , \"hello.hello_user\" , user = \"John\" )) #> Hallo John! print ( _ ( \"jp\" , \"hello.hello_user\" , user = \"\u30b8\u30e7\u30f3\u3055\u3093\" )) #> \u3053\u3093\u306b\u3061\u306f\u3001\u30b8\u30e7\u30f3\u3055\u3093\uff01 Namespaces PyI18n supports namespaces, which allows you to organize your translations into separate groups. To use PyI18n with namespaces, you need to define the loader object yourself. Here's an example: from pyi18n.loaders import PyI18nYamlLoader from pyi18n import PyI18n if __name__ == \"__main__\" : loader : PyI18nYamlLoader = PyI18nYamlLoader ( 'locales/' , namespaced = True ) pyi18n : PyI18n = PyI18n (( 'en_US' , 'de_DE' ), loader = loader ) In this example, we create an instance of the PyI18nYamlLoader class with the namespaced parameter set to True. This tells the loader to look for namespaced locales in separate folders instead of one single file for one locale. Here's an example of the expected file structure for the locales: locales en_US common.yml analysis.yml de_DE common.yml analysis.yml To get a key that is located in the common namespace, you should use the dot notation in your translation call: _ ( locale , 'common.greetings' ) Integrate pyi18n with Django project To integrate pyi18n into your Django project, you will need to first add a locale field to your user model class. This field will store the user's preferred language, which will be used to retrieve the appropriate translations from the locales directory. Next, you will need to configure pyi18n in your settings.py file by creating an instance of the PyI18n class and specifying the available languages. You can also create a gettext function for ease of use. In your views, you can then use the gettext function to retrieve translations based on the user's preferred language. To use translations in templates, you will need to create a custom template tag that utilizes the gettext function. settings.py from pyi18n import PyI18n i18n : PyI18n = PyI18n ([ 'pl' , 'en' ]) _ : callable = i18n . gettext views.py from mysite.settings import _ def index ( request ): translated : str = _ ( request . user . locale , 'hello' , name = \"John\" ) return HttpResponse ( f \"This is an example view. { translated } \" ) register template tag from django import template from mysite.settings import _ register = template . Library () @register . simple_tag def translate ( locale : str , path : str , ** kwargs ): return _ ( locale , path , ** kwargs ) usage in templates NOTE: Wrap this tag inside jinja2 special characters translate request . current_user . locale , \"hello\" , name = \"John\" That's it, you have now successfully installed and configured PyI18n for your project. You can now use the provided gettext function to easily retrieve translations based on the user's preferred language. Additionally, you can use the provided template tag to easily retrieve translations in your templates. And if you need to use custom loaders you can use the PyI18nBaseLoader to create your own loaders. Creating custom loader class To create custom locale loader you have to create a class which will inherit from PyI18nBaseLoader and override load method with all required parameters (see below). You can see an example of custom locale loader in examples/custom_xml_loader.py . from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded # return a dictionary with locale data ... your custom loader logic ... return {} Then pass your custom loader to PyI18n class. from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded ... your custom loader logic ... # have to return a dictionary return {} # don't use load_path in `PyI18n` constructor, if not using default yaml loader if __name__ == \"__main__\" : load_path : str = \"locales/\" loader : PyI18nBaseLoader = MyCustomLoader ( load_path = load_path ) i18n : PyI18n = PyI18n (( \"en\" ,), loader = loader ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John! Tasks Tasks usage $ pyi18n-tasks usage: pyi18n-tasks [ -h ] [ -p PATH ] normalize pyi18n-tasks: error: the following arguments are required: normalize Normalization Normalization process will sort locales alphabetically. The default normalization path is locales/ , you can change it by passing -p argument. $ pyi18n-tasks normalize $ pyi18n-tasks normalize -p my_app/locales/ Run tests python3 tests/run_tests.py For any questions and suggestions or bugs please create an issue. Limitations Normalization task will not work for custom loader classes except xml, cause it's based on loader type field ( If you have an idea how to solve this differently please open the issue with a description ), if you need that use one of build in loaders or user XML loader from example. Roadmap See issues, If I have enough time and come up with a good idea on how this package can be improved, I'll post it there, along with tip. Release History Release History available at https://sectasy0.github.io/pyi18n/home/release-history/ . Contributing Fork it ( https://github.com/sectasy0/pyi18n ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'feat: Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Index"},{"location":"home/#pyi18n","text":"PyI18n is a simple and easy to use internationalization library for Python, inspired by Ruby i18n. Documentation available at https://sectasy0.github.io/pyi18n .","title":"PyI18n"},{"location":"home/#installation","text":"You can install PyI18n via pip: pip install pyi18n-v2","title":"Installation"},{"location":"home/#getting-started","text":"A few motivating and useful examples of how pyi18n can be used. To use PyI18n in your application, you will first need to create a locales folder in the root directory of your project. Within this folder, you can create locale files in the format of your choice (e.g. YAML, JSON). For example: $ mkdir -p my_app/locales $ touch my_app/locales/en.yml $ touch my_app/locales/pl.yml $ touch my_app/locales/de.yml You can then create an instance of the PyI18n class, passing in the desired languages and, optionally, a custom locales directory. from pyi18n import PyI18n # default load_path is locales/ # you can change this path by specifying load_path parameter i18n = PyI18n (( \"en\" , \"pl\" , \"de\" , \"jp\" ), load_path = \"translations/\" ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John! print ( _ ( \"pl\" , \"hello.hello_user\" , user = \"John\" )) #> Witaj John! print ( _ ( \"de\" , \"hello.hello_user\" , user = \"John\" )) #> Hallo John! print ( _ ( \"jp\" , \"hello.hello_user\" , user = \"\u30b8\u30e7\u30f3\u3055\u3093\" )) #> \u3053\u3093\u306b\u3061\u306f\u3001\u30b8\u30e7\u30f3\u3055\u3093\uff01","title":"Getting Started"},{"location":"home/#namespaces","text":"PyI18n supports namespaces, which allows you to organize your translations into separate groups. To use PyI18n with namespaces, you need to define the loader object yourself. Here's an example: from pyi18n.loaders import PyI18nYamlLoader from pyi18n import PyI18n if __name__ == \"__main__\" : loader : PyI18nYamlLoader = PyI18nYamlLoader ( 'locales/' , namespaced = True ) pyi18n : PyI18n = PyI18n (( 'en_US' , 'de_DE' ), loader = loader ) In this example, we create an instance of the PyI18nYamlLoader class with the namespaced parameter set to True. This tells the loader to look for namespaced locales in separate folders instead of one single file for one locale. Here's an example of the expected file structure for the locales: locales en_US common.yml analysis.yml de_DE common.yml analysis.yml To get a key that is located in the common namespace, you should use the dot notation in your translation call: _ ( locale , 'common.greetings' )","title":"Namespaces"},{"location":"home/#integrate-pyi18n-with-django-project","text":"To integrate pyi18n into your Django project, you will need to first add a locale field to your user model class. This field will store the user's preferred language, which will be used to retrieve the appropriate translations from the locales directory. Next, you will need to configure pyi18n in your settings.py file by creating an instance of the PyI18n class and specifying the available languages. You can also create a gettext function for ease of use. In your views, you can then use the gettext function to retrieve translations based on the user's preferred language. To use translations in templates, you will need to create a custom template tag that utilizes the gettext function.","title":"Integrate pyi18n with Django project"},{"location":"home/#settingspy","text":"from pyi18n import PyI18n i18n : PyI18n = PyI18n ([ 'pl' , 'en' ]) _ : callable = i18n . gettext","title":"settings.py"},{"location":"home/#viewspy","text":"from mysite.settings import _ def index ( request ): translated : str = _ ( request . user . locale , 'hello' , name = \"John\" ) return HttpResponse ( f \"This is an example view. { translated } \" )","title":"views.py"},{"location":"home/#register-template-tag","text":"from django import template from mysite.settings import _ register = template . Library () @register . simple_tag def translate ( locale : str , path : str , ** kwargs ): return _ ( locale , path , ** kwargs )","title":"register template tag"},{"location":"home/#usage-in-templates","text":"NOTE: Wrap this tag inside jinja2 special characters translate request . current_user . locale , \"hello\" , name = \"John\" That's it, you have now successfully installed and configured PyI18n for your project. You can now use the provided gettext function to easily retrieve translations based on the user's preferred language. Additionally, you can use the provided template tag to easily retrieve translations in your templates. And if you need to use custom loaders you can use the PyI18nBaseLoader to create your own loaders.","title":"usage in templates"},{"location":"home/#creating-custom-loader-class","text":"To create custom locale loader you have to create a class which will inherit from PyI18nBaseLoader and override load method with all required parameters (see below). You can see an example of custom locale loader in examples/custom_xml_loader.py . from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded # return a dictionary with locale data ... your custom loader logic ... return {} Then pass your custom loader to PyI18n class. from pyi18n.loaders import PyI18nBaseLoader class MyCustomLoader ( PyI18nBaseLoader ): def load ( self , locales : tuple , load_path : str ): # load_path is the path where your loader will look for locales files # locales is a tuple of locales which will be loaded ... your custom loader logic ... # have to return a dictionary return {} # don't use load_path in `PyI18n` constructor, if not using default yaml loader if __name__ == \"__main__\" : load_path : str = \"locales/\" loader : PyI18nBaseLoader = MyCustomLoader ( load_path = load_path ) i18n : PyI18n = PyI18n (( \"en\" ,), loader = loader ) _ : callable = i18n . gettext print ( _ ( \"en\" , \"hello.hello_user\" , user = \"John\" )) #> Hello John!","title":"Creating custom loader class"},{"location":"home/#tasks","text":"","title":"Tasks"},{"location":"home/#tasks-usage","text":"$ pyi18n-tasks usage: pyi18n-tasks [ -h ] [ -p PATH ] normalize pyi18n-tasks: error: the following arguments are required: normalize","title":"Tasks usage"},{"location":"home/#normalization","text":"Normalization process will sort locales alphabetically. The default normalization path is locales/ , you can change it by passing -p argument. $ pyi18n-tasks normalize $ pyi18n-tasks normalize -p my_app/locales/","title":"Normalization"},{"location":"home/#run-tests","text":"python3 tests/run_tests.py For any questions and suggestions or bugs please create an issue.","title":"Run tests"},{"location":"home/#limitations","text":"Normalization task will not work for custom loader classes except xml, cause it's based on loader type field ( If you have an idea how to solve this differently please open the issue with a description ), if you need that use one of build in loaders or user XML loader from example.","title":"Limitations"},{"location":"home/#roadmap","text":"See issues, If I have enough time and come up with a good idea on how this package can be improved, I'll post it there, along with tip.","title":"Roadmap"},{"location":"home/#release-history","text":"Release History available at https://sectasy0.github.io/pyi18n/home/release-history/ .","title":"Release History"},{"location":"home/#contributing","text":"Fork it ( https://github.com/sectasy0/pyi18n ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'feat: Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Contributing"},{"location":"home/license/","text":"MIT License Copyright \u00a9 2022 sectasy0 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"home/release-history/","text":"Version 1.2.1 - 26.03.2023 Enhancements: Remove ugly hack to make tests work due to incorrect imports. Test coverage has been increased to 99%. Version 1.2.0 - 15.03.2023 New Features: Support for namespaces. Enhancements: Implemented guidelines for integration with the Django framework. Refactored the tasks/normalize.py __sort_nested method for improved efficiency. Revised the PyI18n class constructor for better readability and maintainability. Resolved flake8 errors to ensure code adheres to the pep8 standard. Version 1.1.0 - 23.08.2022 New Features: Introduced the normalize task for improved organization. Added the ability to run the normalize task through command-line interface. Version 1.0.0 - 2022-08-12 Initial release.","title":"Release History"},{"location":"home/release-history/#version-121-26032023","text":"Enhancements: Remove ugly hack to make tests work due to incorrect imports. Test coverage has been increased to 99%.","title":"Version 1.2.1 - 26.03.2023"},{"location":"home/release-history/#version-120-15032023","text":"New Features: Support for namespaces. Enhancements: Implemented guidelines for integration with the Django framework. Refactored the tasks/normalize.py __sort_nested method for improved efficiency. Revised the PyI18n class constructor for better readability and maintainability. Resolved flake8 errors to ensure code adheres to the pep8 standard.","title":"Version 1.2.0 - 15.03.2023"},{"location":"home/release-history/#version-110-23082022","text":"New Features: Introduced the normalize task for improved organization. Added the ability to run the normalize task through command-line interface.","title":"Version 1.1.0 - 23.08.2022"},{"location":"home/release-history/#version-100-2022-08-12","text":"Initial release.","title":"Version 1.0.0 - 2022-08-12"},{"location":"started/basic-usage/","text":"Using PyI18n in your application is pretty easy, all you need to do before is create your locale files. Info By default PyI18n will look for your locale files in ./locale directory. Create loacle files You can create as many files as you need for the languages in your application, PyI18n will handle it. $ mkdir locale $ touch locale/en.yml $ touch locale/pl.yml Those files have to be in YAML format, for e.g. you're creating online shop Example pl locale file pl : labels : products : Produkty cart : Koszyk checkout : Z\u0142\u00f3\u017c zam\u00f3wienie messages : cart : empty : Koszyk jest pusty total : \"\u0141\u0105cznie: {total}\" checkout : title : Z\u0142\u00f3\u017c zam\u00f3wienie name : Imi\u0119 surname : Nazwisko email : Email phone : Telefon address : Adres city : Miasto zip : Kod pocztowy country : Kraj payment : Metoda p\u0142atno\u015bci payment_method_card : Karta payment_method_cash : Got\u00f3wka payment_method_transfer : Przelew payment_method_paypal : PayPal payment_method_other : Inne payment_method_other_description : Opis p\u0142atno\u015bci Example en locale file en : labels : products : Products cart : Cart checkout : Checkout messages : cart : empty : Cart is empty total : \"Total: {total}\" checkout : title : Checkout name : Name surname : Surname email : Email phone : Phone address : Address city : City zip : Zip country : Country payment : Payment method payment_method_card : Card payment_method_cash : Cash payment_method_transfer : Transfer payment_method_paypal : PayPal payment_method_other : Other payment_method_other_description : Payment method description Integrate with your application Application structure . \u251c\u2500\u2500 locales \u2502 \u251c\u2500\u2500 en.yml \u2502 \u2514\u2500\u2500 pl.yml \u2514\u2500\u2500 store.py products = { '1' : { 'name' : 'Chocolate' , 'price' : '$2.00' , 'description' : 'A delicious chocolate' , }, '2' : { 'name' : 'Coffee' , 'price' : '$3.00' , 'description' : 'A delicious coffee' , }, '3' : { 'name' : 'Tea' , 'price' : '$1.00' , 'description' : 'A delicious tea' , }, } if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) user_locale : str = input ( 'Enter your locale: ' ) if user_locale . lower () not in available_locales : print ( 'Locale not supported, please select another one' ) sys . exit ( 1 ) i18n : PyI18n = PyI18n ( available_locales ) _ = i18n . gettext print ( _ ( user_locale , 'messages.welcome' )) print ( \"============================\" ) print ( _ ( user_locale , 'labels.products' ) + \": \\n \" ) if not products : print ( _ ( user_locale , 'messages.product_list.empty' )) else : for product in products : print ( f \" { product } - { products [ product ][ 'name' ] } - { products [ product ][ 'price' ] } \" ) Json format files Lets take a look at the example above, we can use json format files as well. Info In this example we're using PyI18nJsonLoader to load translations from translations/ directory. Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. from pyi18n import PyI18n from pyi18n.loaders import PyI18nJsonLoader if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) loader : PyI18nJsonLoader = PyI18nJsonLoader ( 'translations/' ) i18n : PyI18n = PyI18n ( available_locales , loader = loader ) _ = i18n . gettext","title":"Basic usage"},{"location":"started/basic-usage/#create-loacle-files","text":"You can create as many files as you need for the languages in your application, PyI18n will handle it. $ mkdir locale $ touch locale/en.yml $ touch locale/pl.yml Those files have to be in YAML format, for e.g. you're creating online shop Example pl locale file pl : labels : products : Produkty cart : Koszyk checkout : Z\u0142\u00f3\u017c zam\u00f3wienie messages : cart : empty : Koszyk jest pusty total : \"\u0141\u0105cznie: {total}\" checkout : title : Z\u0142\u00f3\u017c zam\u00f3wienie name : Imi\u0119 surname : Nazwisko email : Email phone : Telefon address : Adres city : Miasto zip : Kod pocztowy country : Kraj payment : Metoda p\u0142atno\u015bci payment_method_card : Karta payment_method_cash : Got\u00f3wka payment_method_transfer : Przelew payment_method_paypal : PayPal payment_method_other : Inne payment_method_other_description : Opis p\u0142atno\u015bci Example en locale file en : labels : products : Products cart : Cart checkout : Checkout messages : cart : empty : Cart is empty total : \"Total: {total}\" checkout : title : Checkout name : Name surname : Surname email : Email phone : Phone address : Address city : City zip : Zip country : Country payment : Payment method payment_method_card : Card payment_method_cash : Cash payment_method_transfer : Transfer payment_method_paypal : PayPal payment_method_other : Other payment_method_other_description : Payment method description","title":"Create loacle files"},{"location":"started/basic-usage/#integrate-with-your-application","text":"Application structure . \u251c\u2500\u2500 locales \u2502 \u251c\u2500\u2500 en.yml \u2502 \u2514\u2500\u2500 pl.yml \u2514\u2500\u2500 store.py products = { '1' : { 'name' : 'Chocolate' , 'price' : '$2.00' , 'description' : 'A delicious chocolate' , }, '2' : { 'name' : 'Coffee' , 'price' : '$3.00' , 'description' : 'A delicious coffee' , }, '3' : { 'name' : 'Tea' , 'price' : '$1.00' , 'description' : 'A delicious tea' , }, } if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) user_locale : str = input ( 'Enter your locale: ' ) if user_locale . lower () not in available_locales : print ( 'Locale not supported, please select another one' ) sys . exit ( 1 ) i18n : PyI18n = PyI18n ( available_locales ) _ = i18n . gettext print ( _ ( user_locale , 'messages.welcome' )) print ( \"============================\" ) print ( _ ( user_locale , 'labels.products' ) + \": \\n \" ) if not products : print ( _ ( user_locale , 'messages.product_list.empty' )) else : for product in products : print ( f \" { product } - { products [ product ][ 'name' ] } - { products [ product ][ 'price' ] } \" )","title":"Integrate with your application"},{"location":"started/basic-usage/#json-format-files","text":"Lets take a look at the example above, we can use json format files as well. Info In this example we're using PyI18nJsonLoader to load translations from translations/ directory. Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. from pyi18n import PyI18n from pyi18n.loaders import PyI18nJsonLoader if __name__ == \"__main__\" : available_locales : Tuple [ str ] = ( 'en' , 'pl' ) loader : PyI18nJsonLoader = PyI18nJsonLoader ( 'translations/' ) i18n : PyI18n = PyI18n ( available_locales , loader = loader ) _ = i18n . gettext","title":"Json format files"},{"location":"started/custom-loader/","text":"Writing a custom loader with an example of a loader for XML file format. To create your own loader, you have to inherit from PyI18nBaseLoader class and implement load method. Note Your custom loader load method should return dictionary with translations otherwise your loader will not work. class PyI18nXMLLoader ( PyI18nBaseLoader ): _type : str = \"xml\" # type of loader def load ( self , locales : tuple ) -> dict : # XML loader logic loaded : dict = {} for locale in locales : file_path : str = f \" { self . load_path }{ locale } .xml\" if not exists ( file_path ): continue with open ( file_path , \"r\" , encoding = \"utf-8\" ) as _f : loaded [ locale ] = parse ( _f . read ())[ locale ] return loaded Pass custom loader to PyI18n constructor Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. if __name__ == \"__main__\" : loader : PyI18nXMLLoader = PyI18nXMLLoader ( \"locales/\" ) i18n : PyI18n = PyI18n (( 'en' , 'pl' ), loader = loader ) print ( i18n . gettext ( \"en\" , \"hello.world\" )) print ( i18n . gettext ( \"pl\" , \"hello.world\" )) # >> Hello world! # >> Witaj \u015bwiecie!","title":"Custom loader"},{"location":"started/custom-loader/#pass-custom-loader-to-pyi18n-constructor","text":"Tip Don't pass load_path argument to PyI18n constructor if you're using loader other than PyI18nYamlLoader (build-in). You should specify load_path argument in your loader instead. if __name__ == \"__main__\" : loader : PyI18nXMLLoader = PyI18nXMLLoader ( \"locales/\" ) i18n : PyI18n = PyI18n (( 'en' , 'pl' ), loader = loader ) print ( i18n . gettext ( \"en\" , \"hello.world\" )) print ( i18n . gettext ( \"pl\" , \"hello.world\" )) # >> Hello world! # >> Witaj \u015bwiecie!","title":"Pass custom loader to PyI18n constructor"},{"location":"started/namespaces/","text":"PyI18n supports namespaces, which allows you to organize your translations into separate groups. To use PyI18n with namespaces, you need to define the loader object yourself. Here's an example: from pyi18n.loaders import PyI18nYamlLoader from pyi18n import PyI18n if __name__ == \"__main__\" : loader : PyI18nYamlLoader = PyI18nYamlLoader ( 'locales/' , namespaced = True ) pyi18n : PyI18n = PyI18n (( 'en_US' , 'de_DE' ), loader = loader ) In this example, we create an instance of the PyI18nYamlLoader class with the namespaced parameter set to True. This tells the loader to look for namespaced locales in separate folders instead of one single file for one locale. Here's an example of the expected file structure for the locales: locales en_US common.yml analysis.yml de_DE common.yml analysis.yml To get a key that is located in the common namespace, you should use the dot notation in your translation call: _ ( locale , 'common.greetings' )","title":"Namespaces"},{"location":"started/normalization/","text":"What is normalization? Normalization process will sort your locales in alphabetical order and will remove duplicates. Running normalization task python3 -m pyi18n-tasks normalize Custom path for normalization task python3 -m pyi18n-tasks normalize --path = translations/","title":"Normalize your locales"},{"location":"started/normalization/#running-normalization-task","text":"python3 -m pyi18n-tasks normalize","title":"Running normalization task"},{"location":"started/normalization/#custom-path-for-normalization-task","text":"python3 -m pyi18n-tasks normalize --path = translations/","title":"Custom path for normalization task"},{"location":"started/use-in-django/","text":"To integrate pyi18n into your Django project, you will need to first add a locale field to your user model class. This field will store the user's preferred language, which will be used to retrieve the appropriate translations from the locales directory. Next, you will need to configure pyi18n in your settings.py file by creating an instance of the PyI18n class and specifying the available languages. You can also create a gettext function for ease of use. In your views, you can then use the gettext function to retrieve translations based on the user's preferred language. To use translations in templates, you will need to create a custom template tag that utilizes the gettext function. settings.py from pyi18n import PyI18n i18n : PyI18n = PyI18n ([ 'pl' , 'en' ]) _ : callable = i18n . gettext views.py from mysite.settings import _ def index ( request ): translated : str = _ ( request . user . locale , 'hello' , name = \"John\" ) return HttpResponse ( f \"This is an example view. { translated } \" ) register template tag from django import template from mysite.settings import _ register = template . Library () @register . simple_tag def translate ( locale : str , path : str , ** kwargs ): return _ ( locale , path , ** kwargs ) usage in templates NOTE: Wrap this tag inside jinja2 special characters translate request . current_user . locale , \"hello\" , name = \"John\" That's it, you have now successfully installed and configured PyI18n for your project. You can now use the provided gettext function to easily retrieve translations based on the user's preferred language. Additionally, you can use the provided template tag to easily retrieve translations in your templates. And if you need to use custom loaders you can use the PyI18nBaseLoader to create your own loaders.","title":"Integrate pyi18n with Django project"},{"location":"started/use-in-django/#settingspy","text":"from pyi18n import PyI18n i18n : PyI18n = PyI18n ([ 'pl' , 'en' ]) _ : callable = i18n . gettext","title":"settings.py"},{"location":"started/use-in-django/#viewspy","text":"from mysite.settings import _ def index ( request ): translated : str = _ ( request . user . locale , 'hello' , name = \"John\" ) return HttpResponse ( f \"This is an example view. { translated } \" )","title":"views.py"},{"location":"started/use-in-django/#register-template-tag","text":"from django import template from mysite.settings import _ register = template . Library () @register . simple_tag def translate ( locale : str , path : str , ** kwargs ): return _ ( locale , path , ** kwargs )","title":"register template tag"},{"location":"started/use-in-django/#usage-in-templates","text":"NOTE: Wrap this tag inside jinja2 special characters translate request . current_user . locale , \"hello\" , name = \"John\" That's it, you have now successfully installed and configured PyI18n for your project. You can now use the provided gettext function to easily retrieve translations based on the user's preferred language. Additionally, you can use the provided template tag to easily retrieve translations in your templates. And if you need to use custom loaders you can use the PyI18nBaseLoader to create your own loaders.","title":"usage in templates"}]}